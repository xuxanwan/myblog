---
layout: post
title:  "异或(^/XOR)的研究"
date:   2015-07-24
categories: Java

---
### 简介
 - 异或是一种基于二进制的位运算，用符号XOR或者^表示，其运算法则是对运算符两侧数的每一个二进制位，同值取0，异值取1。它与布尔运算的区别在于，当运算符两侧均为1时，布尔运算的结果为1，异或运算的结果为0。
 - 简单理解就是不进位加法，如1+1=0，,0+0=0,1+0=1。

### 性质

1. 交换律

2. 结合律（即(a^b)^c == a^(b^c)）

3. 对于任何数x，都有x^x=0，x^0=x

4. 自反性 A XOR B XOR B = A XOR  0 = A

### 应用
- 异或运算最常见于多项式除法，不过它最重要的性质还是自反性：``A XOR B XOR B = A``，即对给定的数A，用同样的运算因子（B）作两次异或运算后仍得到A本身。这是一个神奇的性质，利用这个性质，可以获得许多有趣的应用。

- 例如，所有的程序教科书都会向初学者指出，要交换两个变量的值，必须要引入一个中间变量。但如果使用异或，就可以节约一个变量的存储空间： 设有A,B两个变量，存储的值分别为a，b，则以下三行表达式将互换他们的值 表达式 （值） :
    + A=A XOR B (a XOR b)
    + B=B XOR A (b XOR a XOR b = a) 
    + A=A XOR B (a XOR b XOR a = b)
类似地，该运算还可以应用在加密，数据传输，校验等等许多领域。

### 应用举例

- 1-1000放在含有1001个元素的数组中，只有唯一的一个元素值重复，其它均只出现一次。每个数组元素只能访问一次，设计一个算法，将它找出来；不用辅助存储空间，能否设计一个算法实现？
    + 解法一、显然已经有人提出了一个比较精彩的解法，将所有数加起来，减去1+2+...+1000的和。
这个算法已经足够完美了，相信出题者的标准答案也就是这个算法，唯一的问题是，如果数列过大，则可能会导致溢出。
    + 解法二、异或就没有这个问题，并且性能更好。将所有的数全部异或，得到的结果与1\^2\^3\^...\^1000的结果进行异或，得到的结果就是重复数。

    #### 证明:
        1. 这个算法虽然很简单，但证明起来并不是一件容易的事情。这与异或运算的几个特性有关系。首先是异或运算满足交换律、结合律。
        所以，1\^2\^...\^n\^...\^n\^...\^ 1000，无论这两个n出现在什么位置，都可以转换成为1\^2\^...\^1000\^(n\^n)的形式。
        2. 其次，对于任何数x，都有x\^x=0，x\^0=x。
        所以1\^2\^...\^n\^...\^n\^...\^1000 = 1\^2\^...\^ 1000\^(n\^ n)= 1\^2\^ ...\^1000\^0 = 1\^2\^...\^1000（即序列中除了n的所有数的异或）。
        3. 令，1\^2\^...\^1000（序列中不包含n）的结果为T
        则1\^2\^...\^1000（序列中包含n）的结果就是T\^n。
        T\^(T\^n)=n。
        4. 所以，将所有的数全部异或，得到的结果与1\^2\^3 \^...\^1000的结果进行异或，得到的结果就是重复数。当然有人会说，1+2+...+1000的结果有高斯定律可以快速计算，但实际上1\^2\^...\^1000的结果也是有规律的，算法比高斯定律还该简单的多。
